1. 创建视图骨架

   创建以下空文件/类，以使它们符合基本的MVVM结构:

   - View.xaml (所需的UI)
   - ViewModel.cs (视图的数据上下文，实现INotifyPropertyChanged)
   - Model.cs (UI上显示的业务数据)

   ViewModel类有一个接收Model实例的构造函数。

2. 创建所需的工厂

   考虑谁将创建View、ViewModel和Model实例，谁将在它们之间添加引用。创建所需的代码，这样我们就可以在应用程序中创建基础设施并打开视图，以便能够执行下一步。

   在这一步中，我们必须对将创建所有内容的工厂进行编码。

   由于工厂必须创建几个对象实例并返回它们，因此我们创建了一个包含这些实例的类(ViewInfrastructure)，以便工厂的create()方法返回它，从而避免使用out参数。

   避免跳过这一步的诱惑，使用工厂来创建对象遵循单一责任原则，并让我们将所有视图的创建代码放在一起。

   记住在这一步中添加调用工厂的代码，我们已经将它添加到App.xaml.cs中，但你通常会在打开视图的命令中或类似的地方添加它。

3. 用固定的内容对视图进行编码

   在这一步中，我们只需要修改View. xaml文件，它与视图需求一样简单或复杂。

   示例需求相当简单，所以我们简单地实现了它们。完全没有绑定，只有固定的内容。

4. Code the model

   如果模型是在步骤1中创建的，那么是时候填充它了。如果您正在使用现有的类，请跳过此步骤(或使用它来验证设计是否正确)。

   **记住Model类只包含数据，不包含行为，这就是为什么这些类应该只包含属性。**

   实际上，这一步与MVVM无关，而是与面向对象的设计有关。考虑一下你正在建模的对象和你需要的属性，不要建模不需要的属性。因此，首先要做的是找出Model属性及其名称。然后是时候考虑属性类型，考虑最能代表属性值的数据类型。

   谈到这个例子，它的属性非常清楚，唯一的争议可能是围绕BirthDay属性。在这一步中，我们必须完全跳过View需求，并考虑被建模的类。Person有一个BirthDate, Date用DateTime表示，这就是为什么我们这样建模。

5. 创建ViewModel属性

   现在我们必须对ViewModel进行编码。我们的视图有9个固定值，但其中4个依赖于相同的数据(男性或女性)，所以我们需要5个属性在ViewModel中。

   ViewModel转换视图和模型之间的数据，因此属性通常从视图中检索/设置/调整值。

   ViewModel必须是视图不可知的，所以视图概念/类型不应该出现在它上面，这就是为什么我们不把属性放在ViewModel的可见性类型中来显示/隐藏人物图像。相反，我们将使用转换器。这将使ViewModel与视图解耦，从而可以用不同的视图替换视图。

6. 进行绑定

   在这一步中，我们将在视图中替换所有固定的内容，并将其绑定到我们在前一步中创建的ViewModel属性。我们还必须创建所需的转换器。

   在这个例子中，我们需要3个不同的转换器:

   - 一个布尔到可见性的转换器(BooleanToVisibilityConverter)，它是. net框架的一部分。
   - 一个否定的布尔转换器(否定来自ViewModel的布尔值)。
   - 一个负的可见性转换器(返回与BooleanToVisibilityConverter相反的值)。

   最好使用转换器，而不是向ViewModel添加负值，因为我们需要这些值，因为视图的工作方式(它使用单选按钮)，因此将这些值添加到ViewModel，将其与View实现耦合。

7. 创建空命令

   所有数据就绪之后，现在是时候使用命令对行为进行编码了。您必须为视图中执行的每个操作创建一个命令，我们创建了两个空命令，其中包含一个DelegateCommand类。它是一个常见的ICommand实现，可以在Prism包中找到。如果您不想添加引用，也可以在示例中找到源代码。

   创建命令后，我们将它们添加到ViewModel中，并修改在步骤2中创建的工厂，以便ViewModel在构造函数中接收它们。

   最后，我们将命令绑定添加到视图，以便其按钮使用新命令。

8. Code Command Bodies

   你会经常发现命令和视图模型之间存在交叉依赖关系，因为ViewModel包含命令，但命令更新ViewModel。理想情况下，命令应该在构造函数中接收它们的依赖关系，但在这种情况下是不可能的，ViewModel被添加为属性并在工厂中设置。
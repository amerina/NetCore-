[TOC]

### Marten是您领域聚合的理想存储库

这是关于在.NET Core上构建微服务的系列文章的第五篇。

在[第一篇文章]((https://github.com/amerina/NetCoreGrowthGuide/blob/main/ToolStep/MicroServiceBasic/Microservices/Article_CN/第1部分开发计划.md))中，我们介绍了该系列并列出了开发计划:业务用例和解决方案体系结构。

在[第二篇文章](https://github.com/amerina/NetCoreGrowthGuide/blob/main/ToolStep/MicroServiceBasic/Microservices/Article_CN/第2部分用CQRS和MediatR塑造微服务内部架构.md)中，我们描述了如何使用CQRS模式和MediatR库构建一个微服务的内部架构。

在[第三篇文章](https://github.com/amerina/NetCoreGrowthGuide/blob/main/ToolStep/MicroServiceBasic/Microservices/Article_CN/第3部分使用Eureka发现服务.md)中，我们描述了服务发现在基于微服务的架构中的重要性，并给出了Eureka的实际实现。

在[第四篇文章](https://github.com/amerina/NetCoreGrowthGuide/blob/main/ToolStep/MicroServiceBasic/Microservices/Article_CN/第4部分用Ocelot构建API网关.md)中，我们介绍了如何使用Ocelot为微服务构建API网关。

在本文中，我们将稍微后退一步，讨论数据访问以及如何有效地持久化数据。

完整解决方案的源代码可以在我们的[GitHub](https://github.com/amerina/NetCoreGrowthGuide/tree/main/ToolStep/MicroServiceBasic/Microservices)上找到。

#### 持久化是一个已经解决的问题，不是吗?

当.NET Framework的第一个版本在2002年左右问世时，我们有两个主要的数据访问API:数据集DataSet和数据读取器DataReader。数据集，是数据库中表的内存表示，另一方面，数据阅读器承诺让您快速读取数据，但您必须手动将数据推入对象。许多开发人员发现了强大的反射，几乎每个人都开发了自己的ORM。

在过去的日子里，我的团队评估了少数几个这样的框架，这些框架似乎都不是我们的适当解决方案，因为我们正在为保险业构建复杂的应用程序。所以我们决定使用DataReader，并为每次插入、更新和查询手工编写SQL。

几年后，我们构建了今天被称为微型ORM的东西。即使使用我们自己开发的简单工具，我们也能够消除大约70%的数据访问代码。

然后NHibernate时代到来了。作为一个有Java经验的开发人员，我很羡慕我的Java同事有这么好的库，当NHibernate的早期版本可用时，我渴望尝试它。当我们开始在生产中使用NHibernate时，我想使用的是它的2.0版本。多年来，NHibernate一直是我们的首选，并帮助我们完成了许多项目。这是一个令人难以置信的灵活和功能丰富的库。但是微软决定实现他们自己的专有解决方案——Entity Framework。随着它的大力推广，许多.NET公司决定转向EF, NHibernate的流行度和社区开始萎缩。

然后微软推出了.NET Core，一切都变了。他们没有移植现有的实体框架，而是决定从头开始开发一个新版本。因此.NET Core的第一个版本并没有真正的企业级数据访问解决方案。我们现在已经有了.NET Core 3, EF Core仍然缺少许多你期望从成熟的ORM中得到的特性。NHibernate终于出现在.NET Core上了，但我不认为它会重新流行起来，因为围绕它的社区要小得多，而且NHibernate与今天的ORM相比似乎是非常具有侵入性的，例如，它迫使你把所有的属性都变成虚拟的，这样它就可以通过ORM来代理。

.NET Core的到来和微服务的日益普及彻底改变了.NET架构的格局。现在可以在Linux上进行开发和部署。在.NET开发人员中，使用MS SQL以外的数据库越来越流行。
微服务也增加了多语言持久化的流行程度。开发人员意识到他们可以为不同类型的服务使用不同的数据存储。有文档数据库、图形数据库、事件存储和其他类型的数据库相关解决方案。

正如您所看到的，有很多选项可供选择，我想在这篇文章中讨论的一个选项是使用关系数据库作为文档数据库，以达到两全其美的目的。你可以通过[**Marten**](https://jasperfx.github.io/marten/)的帮助做到这一点。

Martenis一个客户端库，它允许.NET开发者使用Postgresql作为文档数据库和事件存储。它是由Jeremy Miller在2015年10月左右开始作为RavenDB数据库的替代品，但它远不止于此。
如果你曾经使用过像MongoDB或RavenDB这样的文档数据库，你就会知道它给了你很好的开发体验，尤其是易用性和开发速度，但有一些与性能和数据一致性相关的问题。

**使用Marten，您可以轻松地将关系数据库作为文档数据库使用，完全符合ACID并广泛支持LINQ。**

从我的角度来看，对于这种方法，有一个特定的用例似乎很理想。如果您正在进行领域驱动设计，并将领域模型划分为小的聚合，则可以将聚合视为文档。如果您采用这种方法并与像Marten这样的库结合使用，那么持久化、加载和查找聚合几乎不需要代码。由于遵从ACID，您可以在同一个事务中修改和保存许多聚合，这在许多文档数据库中是不可能的。使用关系数据库还简化了基础设施管理，因为您仍然可以依靠熟悉的工具进行备份和监视。
更重要的是，领域模型不受ORM能力的限制。

Vaughn Vernon的一篇文章《[The Ideal Domain Driven Design Aggregate Store](https://kalele.io/blog-posts/the-ideal-domain-driven-design-aggregate-store/)》描述了在关系数据库中以JSON格式保存聚合数据的想法，这也是我写这篇文章的灵感来源。

#### Marten是什么?

##### 使用Marten

像往常一样，我们使用NuGet将Marten依赖添加到我们的项目中。

```powershell
Install-Package Marten
```







##### 将Marten添加到项目中

##### 设置Marten

##### 自定义模式和映射

##### 保存聚合

##### 加载聚合

##### 查询

##### 编译查询

##### 修补数据

#### Marten的优缺点

#### 总结
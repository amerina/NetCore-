## 事件、委托与Labmda表达式结构

C#中的事件、委托和Lambda表达式:

在本章中，我们将讨论三个重要的概念，也是最容易混淆的概念，即C#中的事件、委托和Lambda表达式，以及它们在应用程序开发中的工作原理。我真的很兴奋能够发表关于事件、委托和Lambda表达式概念的文章，原因是多年来学生和许多初学者级别的开发人员，甚至是有经验的开发人员都发现很难理解这些概念。甚至在刚开始的日子里，我也很难理解这些概念。因此，本章的目标是提供一个关于C#中如何使用事件、委托和Lambda表达式的大图。要充分利用事件、委托和Lambda表达式概念，您应该而且必须具有C#编程语言的经验。

我们将如何涵盖这些概念?

1. 首先，我们将讨论事件、委托和事件处理程序的角色。您需要了解它们各自的作用，以及它们在. net框架中如何协同工作。
2. 接下来，我们将讨论如何创建事件、委托。以及C#中的EventArgs。在这里，我们将讨论什么是委托以及如何将委托与事件集成，以及自定义事件类的角色是什么。
3. 接下来，我们将讨论处理事件。在这里，我们将创建一个类，它将公开一个或多个事件，以及如何从其他类中使用这些事件，我们将尝试理解使用这些事件的不同技术。
4. 最后，我们将讨论Lambda和Delegate。

在下一篇文章中，我将通过示例讨论C#中事件、委托和事件处理程序的作用。在这篇文章中，我只是给你一个概述，我们是如何计划的，并将涵盖三个重要但最容易混淆的概念，即C#中的事件、委托和Lambda表达式。我希望您会喜欢这个系列的文章。



### C#中事件、委托和事件处理程序的角色

在本文中，我将通过示例讨论C#中的事件、委托和事件处理程序。在本文的最后，我相信，您将理解什么是C#中的事件、委托和事件处理程序，以及事件、委托和事件处理程序在.Net框架中的角色和职责。

首先，我们将讨论事件的角色，然后我们将讨论委托的角色，最后，我们将总结事件处理程序的角色。现在，理解这个概念的一个好方法是通过用绳子类比的旧锡罐的例子。如果你小时候这么做过，你就会知道这是一种有趣的说话方式。这实际上是对事件、委托、事件处理程序和事件参数的一个很好的类比。

![00](Image\00.png)

在左边，我们有一个正在说话的小女孩，在右边，她的爸爸在听。所以，**在这种情况下，我们可以说小女孩是Event Raiser，而正在听的爸爸是Event Handler。在事件引发器和事件处理器之间有一个管道我们称这个管道为委托。当涉及到引发事件和处理事件时，委托是真正使一切成为可能的东西。**它将在事件抬升器(Event Raiser)和事件处理器(Event Handler)之间建立链接，如果没有委托，就不可能抬升事件，也不可能处理事件。

所以，如果你想一下，如果我提出一个事件，它意味着一些事情正在发生，比如孩子对着锡罐说话，那么这实际上是如何传递给父亲的呢?我们认为她的爸爸能听懂孩子在说什么。它穿过管道。这就是委托的作用，等我们继续，我们会更多地讨论委托。

另一个重要的部分是EventArgs，因为当孩子说话时，我们需要数据或信息传递到事件处理程序，也就是说，无论孩子说什么，都应该传递给她的父亲，在.Net世界中，我们称它们为EventArgs。**EventArgs是容器，我们可以在其中传递一个或多个数据。**一旦我们取得进展，我们将讨论更多关于EventArgs的内容。

#### 事件在C#中的作用:

事件是通知。简单地说，我们可以说它是发送给一个或多个正在收听的人(我们也可以说他们是订阅者)的消息。很明显，在.Net中不会是人，而是对象。

事件在.Net框架中扮演着核心角色。它们是.Net框架的重要组成部分，当你在visual studio中输入任何东西时，你都可以看到它们，如果你曾经看到过一个电灯泡类型的图标，那么这就是一个事件。

事件提供了一种触发通知的方法。所以，你可以想象一个人用扩音器或大声向一群人宣布Party即将开始或典礼即将开始。这也是人类世界的一个事件。

在编程的世界里，事件也是一样的东西，只是我们用.Net事件来通知，而不是用扩音器或者大声地说出来。然后我们还会用到委托，EventArgs和EventHandlers。

![00](Image\01.png)



#### 事件示例:

现在，事件最简单的例子是按钮。如果您使用过C#，并且做过任何类型的UI工作，如Windows表单应用程序和Web表单应用程序，那么您可能知道按钮元素有许多事件，如单击事件、鼠标移动和鼠标移出等等。假设您从Windows窗体应用程序的工具箱中拖放按钮控件并将其放在UI中，当您双击按钮元素时，它在幕后生成一个单击事件处理程序。

按钮的示例，我们有一个按钮和一个事件处理程序，它监听按钮单击事件。在C#中的事件中，多个对象监听单个事件是可能的，只要所有对象都附加到事件上，当我们发送通知时，所有与事件相关的对象都将得到通知。

现在，如果一个事件被触发，我们知道发生了一些事情，但通常我们还需要了解一些事件数据，以便进行进一步处理。例如，在订单的情况下，让我们假设下订单的事件被触发，当下订单的事件被触发时，我们可能想要知道关于订单细节的信息，比如他们订购了什么、订购了多少、成本是多少、发货地点、账单地址是什么、发货地址是什么、支付方式是什么等等。

在.Net框架中的大多数事件都有EventsArgs，或者换句话说，事件数据EventArgs从A点(Event Raiser)路由到B点(Event Handler)。

![00](Image\02.png)

这就是事件在C#中的作用。



#### 委托在C#中的作用：

作为开发者，由于. Net框架非常频繁地使用这个委托的概念，主要是在处理自动生成的代码时，我们需要非常好地理解委托。事实上，如果没有委托，事件将毫无用处。原因是我们没有其他方法将事件数据从点A(Event Raiser)传输到点B(Event Handler)。那么，让我们继续，试着理解委托到底是什么，以及为什么在.Net Framework中使用它们。

如果您回到我们的声音听筒传播示例，Event Raiser将发送通知，当然，我们有接收通知的事件监听器或事件处理程序。让我们想象一下，当小女孩说话时，她没有通过话筒说话，让我们假设这个人或父亲，在这种情况下是事件监听者或事件处理者，听不到她说话。这意味着小孩必须对着话筒说话，然后她的讲话通过管道，在右边的人可以听到她。

这里，在本例中，委托只是Event Raiser和Event Handler之间的管道。它是.Net框架中最重要的部分之一，大多数C#开发人员都有很多困惑。

![00](Image\03.png)



#### 什么是.Net框架中的委托?

Delegate是一个专门的类，在接下来的文章中，您将看到.Net Framework中有一个名为Delegate的关键字。委托真正的意思是，一个函数指针。这是技术上的定义，一旦我们开始编程，你就会对函数指针是什么有更好的理解。

但是为了简化这一点，我们可以说**委托是事件引发器和事件处理程序之间的粘合剂或管道，它允许我们的事件和EventArgs到达事件处理程序。**因此，我们需要将数据从A点传输到B点，这只有通过委托才能实现。

现在，当我们使用事件并创建委托时。在.Net中有一个特殊的类叫做MulticastDelegate，这个类实际上跟踪了所有监听事件的人。当事件通知被发送时，假设有一段信息，这段信息需要被发送到所有的监听器。如果我们有50个监听器，那么我们在调用列表中有50个项或对象。在我们即将发布的文章中，我们将通过编程理解这个过程。

![00](Image\04.png)

#### 委托是一个管道:

正如我提到的，委托是管道。我们有了事件，有了管道，还有事件处理器我们需要神奇地从A点(event notification point)获取数据到B点(事件处理器)

在引发事件之前，我们要做的是，我们有EventArgs也就是我们想要从点A发送到点B的事件数据，我们会通过管道发送事件数据。现在，通过管道的数据(EventArgs)将到达事件处理程序。

现在，要由事件处理程序来实际处理事件数据并对其进行处理。在讨论事件处理程序的角色之后，我们将在本文的后面部分讨论事件处理程序如何处理数据。

![00](Image\05.png)

现在，我们将委托称为函数指针的原因是，事件处理程序在C#或者.Net框架术语中是一个函数，我们称它为方法。**委托指向事件处理程序或者你可以说当委托被调用时指向一个函数，所指向的函数或方法或事件处理程序将被执行这就是我们称它为函数指针的原因。**

现在，让我们举一个简单的例子，我们有一个按钮，为了让我们把它从A点路由到B点，我们需要一个委托。当引发按钮的Click事件时，委托从Click事件和附加到委托的将要执行的任何函数或方法(也可以说是事件处理程序)中获取数据并处理数据。

![00](Image\06.png)

这就是委托的工作方式以及它们在幕后的用途。因此，您可以看到，没有委托，事件没有很多用途。尽管您在没有委托的情况可以单独触发一个事件，但没有办法将数据从点A路由到点B。

#### 事件处理程序在C#中的角色:

事件和委托的最后一部分是事件处理程序。当然，如果您以前使用过.Net，这对您来说就不会感到惊讶了。这是因为，如果您使用Windows窗体或Web窗体应用程序，如果您有一个按钮，当您双击它时，它将为按钮元素的单击事件生成一个事件处理程序。

现在，让我们谈谈事件处理程序的基本内容，即事件处理程序是如何工作的。如果你从宏观视角去看，右边的人叫做事件处理程序，那个人或者事件处理程序想要得到一些事件数据我们称之为EventArgs。因此，当Event Raiser触发数据时，委托将数据路由到某种类型的回调函数(事件处理程序)，然后事件处理程序处理数据并对数据进行处理，如更新UI或更新数据库。那么，什么是事件处理程序?

**事件处理程序是C#中的一个方法，它负责接收和处理从委托获得的数据。**

通常，在C#中事件处理程序有两个参数。第一个参数是发送它给你的Sender，它将是一个对象。第二个参数是EventArgs对象。EventArgs只负责封装数据。它就像一个包含数据的容器。EventArgs是定义一些属性的简单方式我们能把很多不同类型的数据放到那些属性中。然后，事件处理程序可以从EventArgs对象获取数据。

![00](Image\07.png)

现在，让我们从全局来看事件处理程序的作用。**事件处理程序负责访问委托传递的数据。**例如，当单击按钮时，我们知道会引发按钮单击事件。谁引发了事件或谁发送了通知，这些信息将存储在Sender对象中这是事件处理程序中的第一个参数，然后我们想传递的数据将存储在EventArgs对象中使用委托把数据从Sender传递到事件处理程序。一旦事件处理程序从委托接收到数据，那么事件处理程序就可以处理数据。为了更好的理解，请看下图。

![00](Image\08.png)

正如您在上面的例子中看到的，我们有一个处理程序，在本例中，我们将其称为btnSubmit_Click事件处理程序。正如你所看到的，它有两个参数，即Sender和EventArgs。在这种情况下，EventArgs是空的，不做任何事情。我们只想知道那个按钮被点击了。就是这样。

但在很多情况下，对于事件，我们会有自定义的EventArgs。在我们接下来的文章中，我将向您展示如何创建自定义EventArgs、自定义委托和自定义事件。

#### 理解C#中的事件、委托和事件处理程序示例:

我们已经讨论了C#中的事件、委托、EventArgs和事件处理程序的概念。现在，让我们看一个简短的示例来总结所有这些内容。这只是一个介绍，你可能会有很多困惑和不解，这是可以接受的。因为无论我们在本文中讨论什么，我们都将在后续的文章中详细讨论这些内容，我希望在阅读完这些文章后，您能够更好地理解事件和委托的概念。

让我们创建一个只有一个按钮的Windows Form应用程序。只需从工具箱中拖动按钮控件并将其放在UI上。UI应该如下图所示。在这里，您可以看到我使用按钮控件的属性将按钮文本更改为Submit。

![00](Image\09.png)

一旦你双击按钮，将为按钮点击事件生成事件处理程序，你可以看到它是一个带有两个参数的方法，即对象sender和EventArgs。sender对象包含关于谁引发了事件的信息，在这种情况下，它是Submit按钮。EventArgs属性包含数据。

![00](Image\10.png)

现在，如果您选择按钮控件并转到属性窗口，那么您可以看到与下图所示的按钮元素相关联的所有事件。

![00](Image\11.png)

我们示例在所有事件中，我们只添加了click事件的处理程序。我们已经看到了按钮元素的事件，也看到了事件处理程序，即click事件处理程序。但是委托在哪里呢?如果您想查看委托，那么展开Form1.cs类文件，您将看到如下图所示的Form1.Designer.cs。

![00](Image\12.png)

现在，打开Form1.Designer.cs类文件，当我们双击UI上的按钮元素时，会生成这个文件。现在，展开Windows Form Designer生成的代码部分，您将看到以下内容。

![00](Image\13.png)

如上图所示，**按钮单击事件由委托包装，该委托指向button1_click回调函数。**那么，这些都是什么，它们是如何工作的，我们将在接下来的课程中详细讨论。这只是对事件、委托和事件处理程序的介绍。你需要记住的一点是如果你在使用一个事件，那么幕后委托就在那里。

#### C#中的事件、委托和事件处理程序摘要:

1. . Net框架严重依赖于事件和委托。
2. 事件提供通知并使用EventArgs发送。
3. 委托充当事件处理程序和事件处理程序之间的胶水或管道。
4. 事件处理程序接收和处理EventArgs数据。

今天就到这里。在我们的下一篇文章中，我们将讨论如何用示例在C#中创建委托、事件和EventArgs。在本文中，我试图解释什么是委托、事件和事件处理程序，以及它们在C#中的角色和职责。我希望您喜欢这篇C#中的事件、委托和事件处理程序文章。

### C#中的委托

























































